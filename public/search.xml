<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Prefix Notation]]></title>
    <url>%2F2019%2F04%2F30%2FPrefix-Notation%2F</url>
    <content type="text"><![CDATA[12( 20 + 5 )( 16 / 4 ) Such expressions which denote procedures, are called combinations. The left and the right elements are called operands, and the element in the middle to indicate the operation is called operator. This is the most common style we have seen by now; however there is another way to construct a procedure known as prefix notation:12( + 20 5 )( / 16 4 ) Instead of injecting the operator between operands, which is a more human readable style, the prefix notation requires the operator always to be at the left most.conditions:1234( define ( abs x ) ( cond (( &gt; x 0 ) x ) (( = x 0 ) 0 ) (( &lt; x 0 ) ( - x )))) The general form can be expressed as: ( cond (&lt;\P1&gt; &lt;\E1&gt;) (&lt;\P2&gt; &lt;\E2&gt;) … (&lt;\Pn&gt; &lt;\En&gt;)) If none of them is evaluated to be true, then the value of the cond will be undefined. It can also be simplified by using else:123( define ( abs x ) ( cond (( &lt; x 0 ) ( - x )) ( else x ))) If there is only two predicates (the expression to be interpreted as either true of false), then it can use a special form if:1234( define ( abs x ) ( if ( &lt; x 0 ) ( - x ) x )) The general form of an if expression is: ( if &lt;\predicate&gt; &lt;\consequent&gt; &lt;\alternative&gt; ) The logic operators: ( and &lt;\E1&gt; … &lt;\En&gt; )( or &lt;\E1&gt; … &lt;\En&gt; )( not ) Then use the logic operators to define a predicate to evaluate if a number id larger or equal to the other one:12( define ( &gt;= x y ) ( or ( &gt; x y ) ( = x y )) That is all the syntax, there is no loop in a functional programming language! RecursionConsidering the factorial function: n! = n ⋅ (n-1) ⋅ (n-2) ⋅ … ⋅2⋅1 Which can be computed as: n! = n ⋅ (n-1)! If we end it up with 1!, then simply output 1. Then the factorial function can be implemented in linear recursion:1234( define ( factorial n ) ( if ( = n 1 ) 1 ( * n ( factorial ( - n 1 ))))) Linear recursion defines that the computation chains of operations is proportional to n and hence grows linearly. There is also another pattern of recursion, known as Tree Recursion. The best example will be the Fibonacci series, in which each element is the sum of the previous two:12345( define ( fib n ) ( cond ( = n 0 ) 0 ) ( = n 1 ) 1 ) ( else ( + ( fib( - n 1 ) ) ( fib( - n 2 ) ))))) You may find out that this procedure is not really efficient because to compute fib( - n 1), fib( - n 2) has to be computed one more time which causes duplicated work. Therefore, instead of Tree Recursion, let’s try to convert it to be Linear Recursion. Reasign the sum of a and b to a, and the previous a to b:1234567( define ( fib n ) ( iterate 1 0 n ))( define ( iterate a b count ) ( if ( = count 0 ) b ( iterate ( + a b ) a ( - count 1 ))))]]></content>
  </entry>
  <entry>
    <title><![CDATA[A Brief Introduce to Redux Saga]]></title>
    <url>%2F2019%2F04%2F28%2FA-Brief-Introduce-to-Redux-Saga%2F</url>
    <content type="text"><![CDATA[If you are quite experienced with redux, which is a predictable state container for JavaScript applications (Note: even thouth React and Redux is a popular combination to build fast and powerful apps, Redux is not necessarily combined with React), you are definitely feeling comfortable with its powerful store which manages all the global states and provides much cleaner logic flows to change them. If you are new to redux, here is the guide to dive before we start our topic.In a complex javascript application, asynchronous function is always one of the most annoying part where encounters tons of bugs. If not handle them properly, the app usually ends up with call back hell. Haven’t heard of CallBack Hell?Well, in javascript, the only way you can suspend a computation and have the rest operations doing later is to put the rest operations into a callback function. This callback function usually returns a Promise (And has a type of Promise&lt;\any&gt;). In order to easily mark those async functions, after ES6 javascript provides extra modifiers async and await, which actually wraps up the original utilities of promise and makes it more readable to programmers. Hummm, sounds like things are going better… NO!! It doesn’t resolve anything! The core problem leads to a callback hell is the hierarchical async calls, for example you have some simple synchronous functions which are in a chain to accomplish some logics:1234a = getSomething( );b = getMore(a);c = getMoreAndMore(b);... It looks fine for now, but what if they all turn out to be async? Then you have to follow the callback style to make them operate one right after another is done:1234567getSomthing( function( a ) &#123; getMore( a, function( b ) &#123; getMoreAndMore( b, function( c ) &#123; //keep going... &#125;); &#125;);&#125;); Or you prefer ES6:12345678async function getSomething( a ) &#123; await b = ToDo( a ); return await getMore( ( b ) =&gt; &#123; return await ToDo( b ); &#125;).then( ( c ) =&gt; &#123; return await ToDo( c ); &#125;).then(...);&#125; Looks really confused? This will getting even uglier if we are using callbacks in loops. Redux ThunksBack to our redux app, we usually want to update some states after an async call to inform the UI that the data is ready to be fetched. That is always achieved by dispatching an action from the component to the reducer:12345678910111213141516async const callAPI = ( ) =&gt; &#123; ... return response;&#125;...async const updateUI = ( ...params ) =&gt; &#123; const res = await callAPI( ); if (res.status === 200) dispatch( &#123;type: "UPDATE", isSuccess: true&#125; );&#125;...render ( ) &#123; ... this.props.isSuccess? showData( ) : showError( )&#125; This isn’t bad, but we are always looking for something better. An advanced way to rewrite it is using redux middleware. Middleware is somewhere you can put the code after the framework receives a request and before it generates a response. For example, we want to add a logger in the redux store so that when the store catches an action, before it returns the new state, the logger can log the previous state and the new generated state. This is what can be added as a middleware:12345678910function logger( store ) &#123; return function wrapDispatch ( next ) &#123; return function dispatchAndLog ( action ) &#123; console.log( "dispatching.. ", action ); let result = next( action ); console.log( "new state", store.getState( ) ); return result; &#125; &#125;&#125; There are more advanced ways to add a logger. If you are interested, please refer to the offical documentation. With our middleware, the previous example can be written in a cleaner way:12345678910const callAPI = ( ) =&gt; &#123; return( ( dispatch ) =&gt; &#123; dispatch( startCallingApiAction ); actualCallApi( ).then( data =&gt; &#123; dispatch(successAction( data )); &#125;).fail( err =&gt; &#123; dispatch( failedAction(err) ); &#125;); &#125;);&#125; The successful response data is wrapped in the payload of the action, sent to the reducer. Once the store updates the data, it will be mapped as a prop back to the component and request for a rerender. This middleware is also called thunk. By applying thunk to decouple the presentation layer, we can get rid of most of the side effects in components, instead, managing and orchestrating side effects in thunks. This is great, so why are we even considering saga? Well, one of the advantages of middleware is that it can be chained. Every middleware mounted in redux store starts an individual thread (or something really looks like a thread in NodeJS). When a middleware captures an action and handles its side effect, it can dispatch a new action to another middleware to do nested logics. This behavior of middleware indicates that thunks can be chained as well, for example thunkA forwards its return payload to thunkB and thunkB forwards its return payload to… Wait! That sounds quite familiar!! Is that the case of callback hell?? Unfortunately, a good thing plus another good feature doesn’t always end up with something better. It could be some shit as well (笑) In this case, true, this is exactly the callback hell. Redux SagaTo handle the possible endless callback functions and also to make it more easily to test in a component which has complicated logics, we need to change our previous thoughts. Just like shifting from Process Oriented Programming to Object Oriented Programming, instead of telling the application how to handle the side effects, suppose it already knows how to call a function and how to dispatch an action, all we need to do is to give instructions about what to do next and we don’t care about how those instructions will be executed (Saga handles the executions).Then the thunks example can be changed as following:123456789101112export function* apiSideEffect( action ) &#123; try&#123; const data = yield call( actualCallApi ); yield put(&#123; type: "SUCCESS", payload: data &#125;); &#125; catch ( err ) &#123; yield put(&#123; type: "FAILED", payload: err &#125;); &#125;&#125;export function* apiSaga( ) &#123; yield takeEvery( "CLICK_TO_CALL_API", apiSideEffect );&#125; There are serval fucntions already being integrated in Saga: Call: the method call will return only a plain object describing the operation so redux-saga can take care of the invocation and returns the result to the generator. The first parameter is the generator function ready to be called and the rest params are all the arguments in the generator. Put: Instead of dispatching an action inside the generator (Don’t ever ever do that), put Returns an object with instructions for the middleware to dispatch the action. Select: Returns value from the selector function, similar with getState( ). Note: It is not recommended to use this function because it returns the value corresponding to the contents of the store state tree, which is most likely a plain Javascript object and is mutable (Redux wants you to handle state immutably, which means return a new state instead of changing the old one). Take: It creates a command object that tells the middleware to wait for a specific action. The resulting behavior of the call Effect is the same as when the middleware suspends the generator until a promise resolves. In the take case, it’ll suspend the generator until a matching action is dispatched By working with Saga, we make the side effects to be declarative rather than imperative. Declarative: describing what the program must accomplish, rather than describe how to accomplish it Imperative: consists of commands for the computer to perform, focuses on describing how a program operates In the case of take, the control is inverted. Instead of the actions being pushed to the handler tasks, the Saga is pulling the action by itself. An additional generator, known as watcher which contains take has to be created to watch a specific action and being triggered once the following action is dispatched in the application. There are two ways to create a watcher, one is using the buid-in functions (Saga Helper):123function* watchFetchData( ) &#123; yield takeEvery( "FETCH_REQUEST", callFetchDataApi );&#125; takeEvery allows multiple request to be proceeding at the same time. Or if you just want the latest request to be fired (the older one will be overrided during each time the watcher is triggered):123function* watchFetchData( ) &#123; yield takeLatest( "FETCH_REQUEST", callFetchDataApi );&#125; However by using take, it is possible to fully control an action observation process to build complex control flow:1234567function* watchFetchData( ) &#123; while(true) &#123; const action = yield take( "FETCH_REQUEST" ); console.log( action ); yield call( callFetchDataApi, action.payload ); &#125;&#125; All right, now you have been exposed to everything you need to know before start trying redux saga on your own. Here is a short overall example that may also help:Store:123const sagaMiddleware = createSagaMiddleware( );const store = createStore( rootReducer, appluMiddleware(sagaMiddleware) );sagaMiddleware.run( watchFetch ); Sagas:12345678910111213function* watchFetch( ): Generator&lt;*, *, *&gt; &#123; yield takeEvery( "FETCH_ACTION", callFetchAPI );&#125;function* callFetchAPI( ): Generator&lt;*, *, *&gt; &#123; try &#123; yield put(&#123; type: "FETCHING", payload: ... &#125;); const data = yield call( actualCallApi ); yield put(&#123; type: "FETCH_SUCCESS", payload: data &#125;); &#125; catch ( err ) &#123; yield put(&#123; type: "FETCH_FAILED", payload: err &#125;); &#125;&#125; Reducer:123456789101112const reducer = ( state = initState, action ) =&gt; &#123; switch( action ) &#123; case "FETCHING": return &#123; loading: true, ...state &#125;; case "FETCH_SUCCESS": return &#123; loading: false, success: true, data: action.payload, ...state &#125;; case "FETCH_FAILED": return &#123; loading: false, success: false, error: true, ...state &#125;; default: return &#123; ...state &#125;; &#125;&#125; Component:123456789101112131415class myComponent extends React.Component &#123; const mapStateToProps = ... const mapDispatchToProps = ... render( ) &#123; return ( &lt;button onClick = &#123; ( ) =&gt; this.props.dispatch(&#123; type: "FETCH_ACTION" &#125;) &#125;/&gt; &#123; this.props.loading? &lt;p&gt;Loading..&lt;/p&gt; : this.props.error? &lt;p&gt;Error!&lt;/p&gt; : &lt;p&gt;&#123;this.props.data&#125;&lt;/p&gt; &#125; ); &#125;&#125;export default connect( mapStateToProps, mapDispatchToProps )( myComponent ); For more advanced concepts, there is a well-organized Saga offical documentation you can refer to if you want to dive deeper. How to test Saga?A function that returns a simple object is easier to test than a function that directly makes an asynchronous call. For redux saga, each time you yield a function call will return a plain javascript object which makes the workflow much easier to test. You don’t need to use the real API, fake it, or mock it, instead just iterating over the generator function, asserting for equality on the values yielded.12345678910describe( "fetch work flow", ( ) =&gt; &#123; const generator = cloneableGenerator( callFetchAPI )(&#123; type: "FETCH_ACTION" &#125;); expect( generator.next( ).value ).toEqual( put(&#123; type: "FETCHING", payload: ... &#125;) ); test( "fetch success", ( ) =&gt; &#123; const clone = generator.clone( ); expect( clone.next( ).value ).toEqual( put(&#123; type: "FETCH_SUCCESS" &#125;) ); expect( generator.next( ).done ).toEqual( true ); &#125;);&#125;); In the above example, we use clone( ) to test different control flows and next( ) to iterate to the next function ready be yielded. The mock return value can also be injected as an argument of next( ):1expect( clone.next( false ).value ).toEqual( put( fetchFailedAction( ) ) ); Saga vs ObservablesRedux saga is not the only solution to our apps which may have complex control flows, they are other helpful tools providing different trade-offs which can also resolve the async problems. Here are some good code snippets of saga vs observables that can open your mind :D References:https://redux-saga.js.org/https://stackoverflow.com/questions/25098066/what-is-callback-hell-and-how-and-why-rx-solves-ithttps://redux.js.org/advanced/middlewarehttps://pub.dartlang.org/packages/redux_thunkhttps://codeburst.io/how-i-test-redux-saga-fcc425cda018https://engineering.universe.com/what-is-redux-saga-c1252fc2f4d1https://www.sitepoint.com/redux-without-react-state-management-vanilla-javascript/https://redux.js.org/introduction/getting-startedhttps://blog.logrocket.com/understanding-redux-saga-from-action-creators-to-sagas-2587298b5e71]]></content>
      <tags>
        <tag>Redux</tag>
        <tag>Saga</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
